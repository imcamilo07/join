-- ================= CONFIGURACI√ìN DE NOMBRES =================
local MAX_SERVERS_A_ESCANEAR = 5 

-- LISTA DE PRIORIDAD (De MENOR a MAYOR importancia)
-- Cuanto m√°s abajo est√© en esta lista, MAS IMPORTANTE ES.
-- El script siempre elegir√° el que est√© m√°s abajo en esta lista.
local TARGET_LIST = {
	"Ketchuru and Musturu",      -- Prioridad 1
	"Tang Tang Kelentang",
	"Tictac Sahur",
	"Ketupat Kepat",
	"Lavadorito Spinito",
	"Garama and Madundung",
	"La Secret Combinasion",
	"La Taco Combinasion",
	"La Supreme Combinasion",
	"Fragrama and Chocrama",
	"Spooky and Pumpky",
	"Gingerat Gerat",
	"Reinito Sleighito",
	"La Casa Boo",
	"Cooki and Milki",
	"Burguro and Fryuro",
	"Headless Horseman",
	"Capitano Moby",
	-- OJO: Seg√∫n tus instrucciones, si sale Ginger y Cannelloni, gana Cannelloni.
	-- Por eso pongo a Cannelloni M√ÅS ABAJO (mayor valor).
	"Dragon Gingerini",
	"Dragon Cannelloni",         -- Gana a Gingerini
	"Meowl",                     -- Gana a los dragones
	"Strawberry Elephant",       -- Gana a Meowl
	"Skibidi Toilet"             -- GANA A TODOS (Prioridad M√°xima)
}

-- ================= SETUP =================
local player = game.Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")
local HttpService = game:GetService("HttpService")

local petMenu
repeat
	petMenu = PlayerGui:FindFirstChild("PetMenu")
	task.wait()
until petMenu

local mainFrame = petMenu:WaitForChild("Frame")
local scrolling = mainFrame:WaitForChild("ScrollingFrame")

local usados = {} 
local joinLock = false 
local cachedRefreshBtn = nil 
local FILE_NAME = "auto_join_nombres_usados.json"

-- Generar tabla de b√∫squeda r√°pida (Nombre -> Valor)
local NAME_VALUES = {}
for i, name in ipairs(TARGET_LIST) do
	NAME_VALUES[name:lower()] = i -- Asigna valor num√©rico (Skibidi = 23, Ketchuru = 1)
end

-- ================= PERSISTENCIA =================
local function cargarUsados()
	if isfile(FILE_NAME) then
		local ok, data = pcall(function() return HttpService:JSONDecode(readfile(FILE_NAME)) end)
		if ok and type(data) == "table" then usados = data end
	end
end

local function guardarUsados()
	pcall(function() writefile(FILE_NAME, HttpService:JSONEncode(usados)) end)
end

cargarUsados()

-- ================= UTILS: PARSEO DE NOMBRES =================
local function parseValor(txt)
	if not txt then return 0, "Nada" end
	local txtLower = txt:lower() -- Convertir a min√∫sculas para comparar
	
	local bestValue = 0
	local bestName = nil

	-- Buscar si el texto contiene alguno de nuestros nombres objetivo
	for name, value in pairs(NAME_VALUES) do
		-- Usamos string.find con 'true' para b√∫squeda exacta de texto plano (sin patrones m√°gicos)
		if string.find(txtLower, name, 1, true) then
			if value > bestValue then
				bestValue = value
				bestName = TARGET_LIST[value] -- Recuperar nombre original bonito
			end
		end
	end
	
	-- Retorna: Valor Num√©rico (para ordenar) y Nombre (para mostrar)
	return bestValue, bestName
end

-- ================= GUI PRINCIPAL =================
local gui = Instance.new("ScreenGui")
gui.Name = "AUTO_JOIN_NAMED_VISUAL"
gui.ResetOnSpawn = false
gui.DisplayOrder = 999999
gui.Parent = PlayerGui

local bigBtn = Instance.new("TextButton")
bigBtn.Size = UDim2.new(0,300,0,100) -- Un poco m√°s grande para nombres largos
bigBtn.Position = UDim2.new(1,-320,0.5,-50)
bigBtn.BackgroundColor3 = Color3.fromRGB(0,170,0)
bigBtn.TextColor3 = Color3.new(1,1,1)
bigBtn.TextScaled = true
bigBtn.Font = Enum.Font.SourceSansBold
bigBtn.Visible = false
bigBtn.Parent = gui

-- ================= GUI LOGS =================
local logsFrame = Instance.new("Frame")
logsFrame.Size = UDim2.new(0,220,0,180)
logsFrame.Position = UDim2.new(0, 10, 0.5, 50) 
logsFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
logsFrame.Visible = false 
logsFrame.Parent = gui
Instance.new("UICorner", logsFrame)

local logsTitle = Instance.new("TextLabel")
logsTitle.Size = UDim2.new(1,0,0,25)
logsTitle.BackgroundTransparency = 1
logsTitle.Text = "üîç ESCANEANDO NOMBRES"
logsTitle.TextColor3 = Color3.fromRGB(255, 200, 0)
logsTitle.Font = Enum.Font.SourceSansBold
logsTitle.TextSize = 14
logsTitle.Parent = logsFrame

local logsText = Instance.new("TextLabel")
logsText.Size = UDim2.new(1,-10,1,-30)
logsText.Position = UDim2.new(0,5,0,30)
logsText.BackgroundTransparency = 1
logsText.TextXAlignment = Enum.TextXAlignment.Left
logsText.TextYAlignment = Enum.TextYAlignment.Top
logsText.Text = "Esperando..."
logsText.TextColor3 = Color3.new(1,1,1)
logsText.Font = Enum.Font.Code
logsText.TextSize = 11 -- Texto m√°s peque√±o para que quepan nombres largos
logsText.Parent = logsFrame

local function updateLogs(servidores, waitTime)
	local txt = ""
	for i, srv in ipairs(servidores) do
		local estado = "‚úÖ"
		if srv.usado then estado = "‚õî(Usado)" end
		if srv.valor == 0 then estado = "üîª(Nada)" end
		
		-- Mostrar nombre corto si es muy largo
		local displayName = srv.encontrado or "---"
		if #displayName > 18 then displayName = displayName:sub(1,16)..".." end
		
		txt = txt .. i .. ". " .. displayName .. " " .. estado .. "\n"
	end
	
	if waitTime then
		txt = txt .. "--- \nCarga: " .. string.format("%.3f", waitTime) .. "s"
	end
	
	logsText.Text = txt
end

-- ================= CORE (LOGICA) =================

local function intentarUnirse(frame, firma, nombreDetectado)
	if joinLock then return end
	joinLock = true
	bigBtn.Visible = false

	local inner = frame:FindFirstChildWhichIsA("Frame")
	if not inner then joinLock = false return end
	local joinBtn = inner:FindFirstChildWhichIsA("TextButton")
	if not joinBtn then joinLock = false return end

	-- Guardamos la firma completa para no repetir server
	usados[firma] = true 
	task.spawn(guardarUsados)
	
	-- 2. CLICK (LA M√ÅXIMA VELOCIDAD AQU√ç)
	for _,conn in ipairs(getconnections(joinBtn.MouseButton1Click)) do
		conn:Fire()
	end
	
	print("üöÄ INTENTO DE UNI√ìN A: " .. (nombreDetectado or "???"))

	-- FIX: Si falla, desbloquear r√°pido
	task.delay(2.5, function()
		if joinLock then
			print("‚ö†Ô∏è Fallo o server lleno, desbloqueando...")
			joinLock = false
		end
	end)
end

local function escanearSmart()
	if joinLock then return end
	
	local hijos = scrolling:GetChildren()
	local candidatos = {}
	local logsData = {} 
	
	local count = 0
	for _,obj in ipairs(hijos) do
		if obj:IsA("Frame") then
			count = count + 1
			if count > MAX_SERVERS_A_ESCANEAR then break end

			local lbl = obj:FindFirstChildWhichIsA("TextLabel")
			if lbl and lbl.Text then
				local txt = lbl.Text
				-- AQUI LA MAGIA: Usamos el nuevo parser de nombres
				local val, nombreEncontrado = parseValor(txt) 
				
				local isUsed = usados[txt] ~= nil
				
				-- Guardar info para el LOG VISUAL
				table.insert(logsData, {firma = txt, valor = val, encontrado = nombreEncontrado, usado = isUsed})

				-- Si val > 0 significa que encontr√≥ uno de la lista
				if val > 0 and not isUsed then
					table.insert(candidatos, {
						frame = obj,
						valor = val, -- Valor num√©rico basado en la posici√≥n de la lista
						firma = txt,
						nombre = nombreEncontrado
					})
				end
			end
		end
	end
	
	-- Actualizar GUI Desplegable
	updateLogs(logsData)

	-- L√≥gica de Selecci√≥n
	if #candidatos > 0 then
		-- Ordenar de Mayor a Menor PRIORIDAD (El que est√© m√°s abajo en la lista gana)
		table.sort(candidatos, function(a,b) return a.valor > b.valor end)
		
		local mejor = candidatos[1]
		
		-- Feedback Visual
		bigBtn.Text = "JOIN: " .. mejor.nombre
		bigBtn.Visible = true
		
		-- üî´ AUTO JOIN
		task.defer(function()
			intentarUnirse(mejor.frame, mejor.firma, mejor.nombre)
		end)
		return true
	else
		bigBtn.Visible = false
		return false
	end
end

-- ================= REFRESH =================

local function getRefreshBtn()
	if cachedRefreshBtn and cachedRefreshBtn.Parent then return cachedRefreshBtn end
	for _,obj in ipairs(mainFrame:GetDescendants()) do
		if obj:IsA("TextButton") and (obj.Text == "Refresh" or obj.ContentText == "Refresh") then
			cachedRefreshBtn = obj
			return obj
		end
	end
end

local function fireRefresh()
	local btn = getRefreshBtn()
	if btn then
		for _,conn in ipairs(getconnections(btn.MouseButton1Click)) do
			conn:Fire()
		end
	end
end

-- ================= CONTROLES GUI =================

local controlPanel = Instance.new("Frame")
controlPanel.Size = UDim2.new(0,160,0,130) 
controlPanel.Position = UDim2.new(1,-450,0.5,-65)
controlPanel.BackgroundColor3 = Color3.fromRGB(25,25,25)
controlPanel.Active = true
controlPanel.Draggable = true
controlPanel.Parent = gui
Instance.new("UICorner", controlPanel)

local logsBtn = Instance.new("TextButton")
logsBtn.Size = UDim2.new(1,-10,0,25)
logsBtn.Position = UDim2.new(0,5,0,5)
logsBtn.Text = "MOSTRAR LOGS: OFF"
logsBtn.BackgroundColor3 = Color3.fromRGB(200, 150, 0)
logsBtn.TextColor3 = Color3.new(1,1,1)
logsBtn.Parent = controlPanel

local autoBtn = Instance.new("TextButton")
autoBtn.Size = UDim2.new(1,-10,0,40)
autoBtn.Position = UDim2.new(0,5,0,35)
autoBtn.Text = "AUTO JOIN: OFF"
autoBtn.TextScaled = true
autoBtn.BackgroundColor3 = Color3.fromRGB(150,50,50)
autoBtn.TextColor3 = Color3.new(1,1,1)
autoBtn.Font = Enum.Font.SourceSansBold
autoBtn.Parent = controlPanel

local cleanBtn = Instance.new("TextButton")
cleanBtn.Size = UDim2.new(1,-10,0,30)
cleanBtn.Position = UDim2.new(0,5,0,80)
cleanBtn.Text = "BORRAR USADOS (CLEAN)"
cleanBtn.BackgroundColor3 = Color3.fromRGB(60,60,60)
cleanBtn.TextColor3 = Color3.new(1,1,1)
cleanBtn.Parent = controlPanel

local autoRefresh = false

logsBtn.MouseButton1Click:Connect(function()
	logsFrame.Visible = not logsFrame.Visible
	logsBtn.Text = logsFrame.Visible and "MOSTRAR LOGS: ON" or "MOSTRAR LOGS: OFF"
end)

autoBtn.MouseButton1Click:Connect(function()
	autoRefresh = not autoRefresh
	autoBtn.Text = autoRefresh and "AUTO JOIN: ON" or "AUTO JOIN: OFF"
	autoBtn.BackgroundColor3 = autoRefresh and Color3.fromRGB(0,150,0) or Color3.fromRGB(150,50,50)
	if autoRefresh and not joinLock then escanearSmart() end
end)

cleanBtn.MouseButton1Click:Connect(function()
	usados = {}
	if isfile(FILE_NAME) then delfile(FILE_NAME) end
	cleanBtn.Text = "¬°DATOS BORRADOS!"
	updateLogs({}) 
	task.delay(1, function() cleanBtn.Text = "BORRAR USADOS (CLEAN)" end)
end)

-- ================= LOOP INTELIGENTE (MAX SPEED) =================

task.spawn(function()
	while true do
		if autoRefresh and not joinLock then
			
			fireRefresh()
			
			-- SMART WAIT
			local start = tick()
			local items = 0
			
			repeat 
				items = 0
				for _,c in ipairs(scrolling:GetChildren()) do
					if c:IsA("Frame") then items = items + 1 end
				end
				task.wait() 
			until items >= MAX_SERVERS_A_ESCANEAR or (tick() - start) > 0.5
			
			local waitTime = tick() - start
			task.wait(0.05) -- Estabilizaci√≥n
			
			escanearSmart()
			
			if logsFrame.Visible then
				-- Actualizamos solo el tiempo, ya que escanearSmart actualiz√≥ la data
				-- Esto es un peque√±o hack visual para no re-calcular todo
				logsText.Text = logsText.Text:gsub("Carga: .-s", "Carga: " .. string.format("%.3f", waitTime) .. "s")
			end
		end
		
		task.wait(0.01) 
	end
end)
