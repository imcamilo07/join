-- ================= CONFIG =================
local MAX_SERVERS_A_ESCANEAR = 5 -- Revisar solo los primeros N servidores
local MIN_JOIN_VALUE = 200e6 -- 200M m√≠nimo

-- ================= SETUP =================
local player = game.Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")
local HttpService = game:GetService("HttpService")

local petMenu
repeat
	petMenu = PlayerGui:FindFirstChild("PetMenu")
	task.wait()
until petMenu

local mainFrame = petMenu:WaitForChild("Frame")
local scrolling = mainFrame:WaitForChild("ScrollingFrame")

local usados = {} 
local joinLock = false 
local cachedRefreshBtn = nil 
local FILE_NAME = "auto_join_usados.json"

-- ================= PERSISTENCIA =================
local function cargarUsados()
	if isfile(FILE_NAME) then
		local ok, data = pcall(function() return HttpService:JSONDecode(readfile(FILE_NAME)) end)
		if ok and type(data) == "table" then usados = data end
	end
end

local function guardarUsados()
	pcall(function() writefile(FILE_NAME, HttpService:JSONEncode(usados)) end)
end

cargarUsados()

-- ================= UTILS: PARSEO ROBUSTO RESTAURADO =================
local function parseValor(txt)
    if not txt then return nil end
    -- Eliminar espacios para simplificar el parseo
    txt = txt:gsub("%s+", "")

    local maxValue = 0 -- Inicializar con 0 para encontrar el m√°ximo
    local foundValue = false

    -- Buscar todos los patrones como 65M, 420B, etc.
    for num, suf in txt:gmatch("([%d%.]+)([MB])") do
        local n = tonumber(num)
        if n then
            local value = (suf == "B" and n * 1e9) or (suf == "M" and n * 1e6)
            
            if value then
                foundValue = true
                if value > maxValue then
                    maxValue = value
                end
            end
        end
    end
    
    -- Devolver nil si no se encontr√≥ ning√∫n valor, o el valor m√°ximo encontrado
    return foundValue and maxValue or nil
end

-- ================= GUI PRINCIPAL =================
local gui = Instance.new("ScreenGui")
gui.Name = "AUTO_JOIN_PRO_VISUAL"
gui.ResetOnSpawn = false
gui.DisplayOrder = 999999
gui.Parent = PlayerGui

local bigBtn = Instance.new("TextButton")
bigBtn.Size = UDim2.new(0,260,0,90)
bigBtn.Position = UDim2.new(1,-280,0.5,-45)
bigBtn.BackgroundColor3 = Color3.fromRGB(0,170,0)
bigBtn.TextColor3 = Color3.new(1,1,1)
bigBtn.TextScaled = true
bigBtn.Font = Enum.Font.SourceSansBold
bigBtn.Visible = false
bigBtn.Parent = gui

-- ================= GUI LOGS =================
local logsFrame = Instance.new("Frame")
logsFrame.Size = UDim2.new(0,200,0,180)
logsFrame.Position = UDim2.new(0, 10, 0.5, 50) 
logsFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
logsFrame.Visible = false 
logsFrame.Parent = gui
Instance.new("UICorner", logsFrame)

local logsTitle = Instance.new("TextLabel")
logsTitle.Size = UDim2.new(1,0,0,25)
logsTitle.BackgroundTransparency = 1
logsTitle.Text = "üîç ESCANEANDO (TOP 5)"
logsTitle.TextColor3 = Color3.fromRGB(255, 200, 0)
logsTitle.Font = Enum.Font.SourceSansBold
logsTitle.TextSize = 14
logsTitle.Parent = logsFrame

local logsText = Instance.new("TextLabel")
logsText.Size = UDim2.new(1,-10,1,-30)
logsText.Position = UDim2.new(0,5,0,30)
logsText.BackgroundTransparency = 1
logsText.TextXAlignment = Enum.TextXAlignment.Left
logsText.TextYAlignment = Enum.TextYAlignment.Top
logsText.Text = "Esperando..."
logsText.TextColor3 = Color3.new(1,1,1)
logsText.Font = Enum.Font.Code
logsText.TextSize = 12
logsText.Parent = logsFrame

local function updateLogs(servidores, waitTime)
	local txt = ""
	for i, srv in ipairs(servidores) do
		local estado = "‚úÖ"
		if srv.usado then estado = "‚õî(Usado)" end
		if srv.valor < MIN_JOIN_VALUE then estado = "üîª(Bajo)" end
		
		txt = txt .. i .. ". " .. srv.firma .. " | " .. math.floor(srv.valor / 1e6) .. "M " .. estado .. "\n"
	end
	
	if waitTime then
		txt = txt .. "--- \nTiempo de carga: " .. string.format("%.3f", waitTime) .. "s"
	end
	
	logsText.Text = txt
end

-- ================= CORE (LOGICA) =================

local function intentarUnirse(frame, firma)
	if joinLock then return end
	joinLock = true
	bigBtn.Visible = false

	local inner = frame:FindFirstChildWhichIsA("Frame")
	if not inner then joinLock = false return end
	local joinBtn = inner:FindFirstChildWhichIsA("TextButton")
	if not joinBtn then joinLock = false return end

	usados[firma] = true
	task.spawn(guardarUsados)
	
	-- 2. CLICK (LA M√ÅXIMA VELOCIDAD AQU√ç)
	for _,conn in ipairs(getconnections(joinBtn.MouseButton1Click)) do
		conn:Fire()
	end
	
	print("üöÄ INTENTO DE UNI√ìN: " .. firma)

	-- FIX: Si falla, desbloquear r√°pido
	task.delay(2.5, function()
		if joinLock then
			print("‚ö†Ô∏è Fallo, desbloqueando...")
			joinLock = false
		end
	end)
end

local function escanearSmart()
	if joinLock then return end
	
	local hijos = scrolling:GetChildren()
	local candidatos = {}
	local logsData = {} 
	
	local count = 0
	for _,obj in ipairs(hijos) do
		if obj:IsA("Frame") then
			count = count + 1
			if count > MAX_SERVERS_A_ESCANEAR then break end

			local lbl = obj:FindFirstChildWhichIsA("TextLabel")
			if lbl and lbl.Text then
				local txt = lbl.Text
				local val = parseValor(txt) or 0
				local isUsed = usados[txt] ~= nil
				
				-- Guardar info para el LOG VISUAL
				table.insert(logsData, {firma = txt, valor = val, usado = isUsed})

				if val >= MIN_JOIN_VALUE and not isUsed then
					table.insert(candidatos, {
						frame = obj,
						valor = val,
						firma = txt
					})
				end
			end
		end
	end
	
	-- Actualizar GUI Desplegable (Sin el tiempo de espera, se agrega despu√©s)
	updateLogs(logsData)

	-- L√≥gica de Selecci√≥n
	if #candidatos > 0 then
		-- Ordenar de Mayor a Menor (NECESARIO)
		table.sort(candidatos, function(a,b) return a.valor > b.valor end)
		
		local mejor = candidatos[1]
		
		-- Feedback Visual
		bigBtn.Text = "JOIN " .. mejor.firma
		bigBtn.Visible = true
		
		-- üî´ AUTO JOIN (Se ejecuta en la pr√≥xima iteraci√≥n del bucle principal para no bloquear)
		task.defer(function()
			intentarUnirse(mejor.frame, mejor.firma)
		end)
		return true
	else
		bigBtn.Visible = false
		return false
	end
end

-- ================= REFRESH =================

local function getRefreshBtn()
	if cachedRefreshBtn and cachedRefreshBtn.Parent then return cachedRefreshBtn end
	for _,obj in ipairs(mainFrame:GetDescendants()) do
		if obj:IsA("TextButton") and (obj.Text == "Refresh" or obj.ContentText == "Refresh") then
			cachedRefreshBtn = obj -- Guardar en cach√©
			return obj
		end
	end
end

local function fireRefresh()
	local btn = getRefreshBtn()
	if btn then
		for _,conn in ipairs(getconnections(btn.MouseButton1Click)) do
			conn:Fire()
		end
	end
end

-- ================= CONTROLES GUI =================

local controlPanel = Instance.new("Frame")
controlPanel.Size = UDim2.new(0,160,0,130) 
controlPanel.Position = UDim2.new(1,-450,0.5,-65)
controlPanel.BackgroundColor3 = Color3.fromRGB(25,25,25)
controlPanel.Active = true
controlPanel.Draggable = true
controlPanel.Parent = gui
Instance.new("UICorner", controlPanel)

local logsBtn = Instance.new("TextButton")
logsBtn.Size = UDim2.new(1,-10,0,25)
logsBtn.Position = UDim2.new(0,5,0,5)
logsBtn.Text = "MOSTRAR LOGS: OFF"
logsBtn.BackgroundColor3 = Color3.fromRGB(200, 150, 0)
logsBtn.TextColor3 = Color3.new(1,1,1)
logsBtn.Parent = controlPanel

local autoBtn = Instance.new("TextButton")
autoBtn.Size = UDim2.new(1,-10,0,40)
autoBtn.Position = UDim2.new(0,5,0,35)
autoBtn.Text = "AUTO JOIN: OFF"
autoBtn.TextScaled = true
autoBtn.BackgroundColor3 = Color3.fromRGB(150,50,50)
autoBtn.TextColor3 = Color3.new(1,1,1)
autoBtn.Font = Enum.Font.SourceSansBold
autoBtn.Parent = controlPanel

local cleanBtn = Instance.new("TextButton")
cleanBtn.Size = UDim2.new(1,-10,0,30)
cleanBtn.Position = UDim2.new(0,5,0,80)
cleanBtn.Text = "BORRAR DATOS (CLEAN)"
cleanBtn.BackgroundColor3 = Color3.fromRGB(60,60,60)
cleanBtn.TextColor3 = Color3.new(1,1,1)
cleanBtn.Parent = controlPanel

local autoRefresh = false

logsBtn.MouseButton1Click:Connect(function()
	logsFrame.Visible = not logsFrame.Visible
	logsBtn.Text = logsFrame.Visible and "MOSTRAR LOGS: ON" or "MOSTRAR LOGS: OFF"
end)

autoBtn.MouseButton1Click:Connect(function()
	autoRefresh = not autoRefresh
	autoBtn.Text = autoRefresh and "AUTO JOIN: ON" or "AUTO JOIN: OFF"
	autoBtn.BackgroundColor3 = autoRefresh and Color3.fromRGB(0,150,0) or Color3.fromRGB(150,50,50)
	if autoRefresh and not joinLock then escanearSmart() end
end)

cleanBtn.MouseButton1Click:Connect(function()
	usados = {}
	if isfile(FILE_NAME) then delfile(FILE_NAME) end
	cleanBtn.Text = "¬°DATOS BORRADOS!"
	updateLogs({}) 
	task.delay(1, function() cleanBtn.Text = "BORRAR DATOS (CLEAN)" end)
end)

-- ================= LOOP INTELIGENTE (MAX SPEED) =================

task.spawn(function()
	while true do
		if autoRefresh and not joinLock then
			
			-- 1. Disparar Refresh
			fireRefresh()
			
			-- 2. ‚ö° SMART WAIT (Calcula el tiempo de carga)
			local start = tick()
			local items = 0
			
			repeat 
				items = 0
				for _,c in ipairs(scrolling:GetChildren()) do
					-- Contar solo los Frames de servidor
					if c:IsA("Frame") then items = items + 1 end
				end
				task.wait() -- M√≠nima pausa para evitar saturar el CPU
			until items >= MAX_SERVERS_A_ESCANEAR or (tick() - start) > 0.5 -- M√°ximo 0.5s de espera
			
			local waitTime = tick() - start
			
			-- 3. Peque√±a estabilizaci√≥n final para asegurar la lectura del texto
			task.wait(0.05)
			
			-- 4. Escanear
			escanearSmart()
			
			-- 5. Actualizar Logs con el tiempo de espera real
			if logsFrame.Visible then
				local currentLogs = {}
				for i=1, #logsText.Text:split("\n") do 
					local line = logsText.Text:split("\n")[i]
					if line:match("%d%..*") then table.insert(currentLogs, {firma=line}) end
				end
				-- Simplemente actualizamos el log con el tiempo. El escaner ya lo llen√≥.
				updateLogs(logsData or {}, waitTime)
			end
		end
		
		-- PAUSA M√çNIMA DEL LOOP (0.01s - casi constante)
		task.wait(0.01) 
	end
end)
